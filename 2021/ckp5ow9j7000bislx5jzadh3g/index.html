

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;light&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="本文章就『Lending Club贷款数据转换与融合』、『行星数据分组与聚合』以及『德国能源数据时间序列分析』等案例对Pandas中的部分分析方法以及机器学习中部分算法进行总结。">
  <meta name="author" content="meurice">
  <meta name="keywords" content="">
  
  <title>大数据处理技术复习要点总结[Pandas] - meurice&#39;s Notes</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"meurice.xyz","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="meurice's Notes" type="application/atom+xml">
</head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>meurice's Notes</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/index_img.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.7)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="大数据处理技术复习要点总结[Pandas]">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      meurice
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-25 13:39" pubdate>
        May 25, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      120
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">大数据处理技术复习要点总结[Pandas]</h1>
            
            <div class="markdown-body">
              <p>本文章就『Lending Club贷款数据转换与融合』、『行星数据分组与聚合』以及『德国能源数据时间序列分析』等案例对Pandas中的部分分析方法以及机器学习中部分算法进行总结。<br><a id="more"></a></p>
<h2 id="Lending-Club贷款数据转换与融合"><a href="#Lending-Club贷款数据转换与融合" class="headerlink" title="Lending Club贷款数据转换与融合"></a>Lending Club贷款数据转换与融合</h2><p> 　　该案例完整Jupyter Notebook可参考<a href="http://cookdata.cn/note/view_static_note/5acc2adb881ca8e68cfbb1cd1347d28d/" target="_blank" rel="noopener">Lending Club贷款数据转换与融合</a>。</p>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">user</span> = pd.read_csv(<span class="hljs-string">"./input/user.csv"</span>)<br><span class="hljs-attr">loan</span> = pd.read_csv(<span class="hljs-string">"./input/loan.csv"</span>)<br><span class="hljs-attr">history</span> = pd.read_csv(<span class="hljs-string">"./input/history.csv"</span>)<br></code></pre></td></tr></table></figure>
<h3 id="随机采样-sample"><a href="#随机采样-sample" class="headerlink" title="随机采样(sample)"></a>随机采样(sample)</h3><p>　　随机查看贷款交易数据中的5行。 </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">loan.sample(<span class="hljs-attribute">n</span>=5)<br></code></pre></td></tr></table></figure>
<p>　　随机查看贷款交易数据中的1%。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">loan.sample(<span class="hljs-attribute">frac</span>=0.01)<br></code></pre></td></tr></table></figure><br>　　sample默认的是不放回采样（每个样本只可能出现一次），可以调整replace参数为True改为有放回采样。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">loan.sample(<span class="hljs-built_in">n</span>=<span class="hljs-number">10</span>,<span class="hljs-built_in">replace</span>=<span class="hljs-built_in">True</span>)<br></code></pre></td></tr></table></figure><br>　　若希望重复调用某次采样的结果，可以设定random_state参数为同一个数来实现。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">loan.sample(n=<span class="hljs-number">5</span>,random_state=<span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure><br>　　除了行采样，sample也可以实现列采样，只需要调整axis参数为1即可。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">loan.sample(n=<span class="hljs-number">3</span>,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></p>
<h3 id="数据融合-merge-join"><a href="#数据融合-merge-join" class="headerlink" title="数据融合(merge,join)"></a>数据融合(merge,join)</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">test_user = user.loc[[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]<br>test_loan = loan[loan.user.isin([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>])]<br></code></pre></td></tr></table></figure>
<p>　　merge和join作为Pandas中常用的数据融合方法，目的都是将两个数据表通过共同变量进行连接。  </p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>　　merge参数如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">left.merge(right, <span class="hljs-attribute">how</span>=<span class="hljs-string">'inner'</span>, <span class="hljs-attribute">on</span>=None, <br>		<span class="hljs-attribute">left_on</span>=None, <span class="hljs-attribute">right_on</span>=None, <br>		<span class="hljs-attribute">left_index</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">right_index</span>=<span class="hljs-literal">False</span>, <br>		<span class="hljs-attribute">sort</span>=<span class="hljs-literal">False</span>, suffixes=(<span class="hljs-string">'_x'</span>, <span class="hljs-string">'_y'</span>), <span class="hljs-attribute">indicator</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><br>　　left和right分别指代要进行连接的两个数据框。<br>　　on, left_on, right_on, 用来指定连接的变量。若这一变量在两个数据框中命名相同，直接使用on指定即可，否则通过left_on和right_on分别指定左表变量名和右表变量名。<br>　　若需要基于数据框的索引进行连接，则要通过设定left_index和right_index的参数为True来实现。<br>　　how为连接方式，有’inner’, ‘left’, ‘right’, ‘outer’四种。  </p>
<p>　　基于用户信息数据的’user_id’变量和贷款交易数据的’user’变量进行内连接(inner)。这种方式下，只有所选定列在左表与右表能匹配的行会被保留。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">test_user.merge(test_loan,<span class="hljs-attribute">how</span>=<span class="hljs-string">"inner"</span>,<br>				<span class="hljs-attribute">left_on</span>=<span class="hljs-string">"user_id"</span>,right_on="user")<br></code></pre></td></tr></table></figure><br>　　基于用户信息数据的’user_id’变量和贷款交易数据的’user’变量进行左连接(left)。这种方式下，左表所有行都被保留，不能匹配的部分用缺失值填充。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">test_user.merge(test_loan,<span class="hljs-attribute">how</span>=<span class="hljs-string">"left"</span>,<br>				<span class="hljs-attribute">left_on</span>=<span class="hljs-string">"user_id"</span>,right_on="user")<br></code></pre></td></tr></table></figure><br>　　基于用户信息数据的’user_id’变量和贷款交易数据的’user’变量进行右连接(right)。这种方式下，右表所有行都被保留，不能匹配的部分用缺失值填充。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">test_user.merge(test_loan,<span class="hljs-attribute">how</span>=<span class="hljs-string">"right"</span>,<br>				<span class="hljs-attribute">left_on</span>=<span class="hljs-string">"user_id"</span>,right_on="user")<br></code></pre></td></tr></table></figure><br>　　基于用户信息数据的’user_id’变量和贷款交易数据的’user’变量进行外连接(outer)。这种方式下，左表和右表所有行都会被保留，不能匹配的部分用缺失值填充。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">test_user.merge(test_loan,<span class="hljs-attribute">how</span>=<span class="hljs-string">"outer"</span>,<br>				<span class="hljs-attribute">left_on</span>=<span class="hljs-string">"user_id"</span>,right_on="user")<br></code></pre></td></tr></table></figure><br>　　merge中的indicator参数能很好地找到返回结果的来源,设定indicator参数为Ture后，返回结果中多了一列”_merge”，取值有”both”, “left_only”, “right_only”三种。分别代表左右表匹配成功，左表有而右表没有，右表有而左表没有三种情况。  </p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c}
 & .. & \_merge \\
\hline
 0 & .. & both \\
\hline
 1 & .. & left\_only \\
\hline
 2 & .. & right\_only
\end{array}</script><p>　　当左表与右表中变量同名时，我们可以通过suffixes参数为左表变量与右表变量附加不同字段，便于后续区分。  </p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c|c|c}
 & user & term\_l & grade\_l & .. & term\_r & grade\_r & .. \\
\hline
0 & 6 & 60 months & .. & .. & 60 months & .. & .. \\
\hline
.. & .. & .. & .. & .. & .. & .. & ..
\end{array}</script><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>　　join参数如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">left.join(right, <span class="hljs-attribute">on</span>=None, <span class="hljs-attribute">how</span>=<span class="hljs-string">'left'</span>,<br>		<span class="hljs-attribute">lsuffix</span>=<span class="hljs-string">''</span>, <span class="hljs-attribute">rsuffix</span>=<span class="hljs-string">''</span>, <span class="hljs-attribute">sort</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><br>　　事实上，join就是merge的简化版本，所有join能实现的操作，都可以使用merge实现。  </p>
<ul>
<li>使用join时，右表只能基于索引进行连接；  </li>
<li>通过on参数，可以指定左表进行连接的变量（可以是索引也可以是任意列）。   </li>
</ul>
<p>　　merge和join中还有一个参数sort，指定为True会让返回的结果按连接变量进行升序排列。  </p>
<h3 id="排序-sort-index-sort-values"><a href="#排序-sort-index-sort-values" class="headerlink" title="排序(sort_index,sort_values)"></a>排序(sort_index,sort_values)</h3><p>　　Pandas中的sort_index和sort_values也可以对DataFrame进行排序，sort_index是按照索引进行排序，sort_values是按照指定变量排序。<br>　　例如想将用户历史数据按账户平均存款排序。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">history.sort<span class="hljs-constructor">_values(<span class="hljs-params">by</span>='<span class="hljs-params">avg_cur_bal</span>')</span><br></code></pre></td></tr></table></figure><br>　　若要降序排列，可以指定ascending参数为False。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">history.sort_values(<span class="hljs-attribute">by</span>=<span class="hljs-string">'avg_cur_bal'</span>,<br>					<span class="hljs-attribute">ascending</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><br>　　也可以指定对缺失值的排序方式，默认缺失值将排在最后，可以设定na_position为first将缺失值排在最前面。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">history.sort_values(<span class="hljs-attribute">by</span>=<span class="hljs-string">'avg_cur_bal'</span>,<br>					<span class="hljs-attribute">na_position</span>=<span class="hljs-string">'first'</span>)<br></code></pre></td></tr></table></figure></p>
<h3 id="离散化-cut-qcut"><a href="#离散化-cut-qcut" class="headerlink" title="离散化(cut,qcut)"></a>离散化(cut,qcut)</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>　　使用cut函数按照指定的分割点对数据进行划分。<br>　　通过设定bin参数设定了分割点，将数据按照中位数进行了划分。同时设定了参数labels，使用这个参数可以方便地为新的划分区间命名。<br>　　<strong>左开右闭区间</strong>  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">annual_inc = pd.cut(<span class="hljs-built_in">combine</span>.annual_inc,<br>					bins=[<span class="hljs-built_in">np</span>.<span class="hljs-built_in">min</span>(<span class="hljs-built_in">combine</span>.annual_inc)-<span class="hljs-number">1</span>,<br>                    	<span class="hljs-built_in">np</span>.percentile(<span class="hljs-built_in">combine</span>.annual_inc,<span class="hljs-number">50</span>),<br>                    	<span class="hljs-built_in">np</span>.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">combine</span>.annual_inc)+<span class="hljs-number">1</span>],<br>					<span class="hljs-built_in">labels</span>=['low','high'])<br></code></pre></td></tr></table></figure>
<p>　　cut也可以直接指定划分份数，将数据等距划分。<br>　　例如，将数据等距分为五份：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">pd</span><span class="hljs-selector-class">.cut</span>(<span class="hljs-selector-tag">combine</span><span class="hljs-selector-class">.annual_inc</span>,5)<br></code></pre></td></tr></table></figure><br>　　理论上，数据应被等距分为了五份，每一个区间的长度都相同，但我们计算可以发现，第一个区间的长度为113364，而其他几个区间的长度都为112800。这并不是cut分割错误，只是为了包含最小值或最大值，<strong>cut的左右端会拓展0.1%</strong>。</p>
<h4 id="qcut"><a href="#qcut" class="headerlink" title="qcut"></a>qcut</h4><p>　　Pandas中与cut相似的另一个函数是qcut，它将按照每个区间中频数相同的原则进行划分,当我们指定划分份数后，就会用相应的分位数进行划分。例如，当我们使用qcut将数据分为两份时，分割点就是中位数，四份时分割点就是四分位数。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">pd</span><span class="hljs-selector-class">.qcut</span>(<span class="hljs-selector-tag">combine</span><span class="hljs-selector-class">.annual_inc</span>,2)<br></code></pre></td></tr></table></figure></p>
<h3 id="值替换-replace-map"><a href="#值替换-replace-map" class="headerlink" title="值替换(replace,map)"></a>值替换(replace,map)</h3><p>　　认为状态为”Charged Off”,”In Grace Period”, “Late (31-120 days)”的贷款有违约风险，视为不良贷款，将其值标记为1，其他贷款标记为0。<br>　　使用replace进行值替换。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">combine</span>[<span class="hljs-string">'loan_status'</span>].<span class="hljs-built_in">replace</span>(<br>	to_replace=[<span class="hljs-string">'Fully Paid'</span>,<span class="hljs-string">'Current'</span>,<span class="hljs-string">'Charged Off'</span>,<span class="hljs-string">'In Grace Period'</span>,<span class="hljs-string">'Late (31-120 days)'</span>],<br>    <span class="hljs-built_in">value</span>=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],<br>    inplace=True)<br></code></pre></td></tr></table></figure><br>　　除了将需要替换的值与替换的新值分别用列表输入外，也可以使用字典进行指定。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">test_loan.replace(to_replace=&#123;<span class="hljs-string">'loan_status'</span>:&#123;<span class="hljs-string">'Fully Paid'</span>:<span class="hljs-number">0</span>,<span class="hljs-string">'Charged Off'</span>:<span class="hljs-number">0</span>,<span class="hljs-string">'In Grace Period'</span>:<span class="hljs-number">1</span>&#125;&#125;)<br></code></pre></td></tr></table></figure><br>　　也可以同时指定不同变量的不同值替换为相同新值。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">test_loan.replace(to_replace=&#123;<span class="hljs-string">'loan_status'</span>:<span class="hljs-string">'Fully Paid'</span>,<span class="hljs-string">'grade'</span>:<span class="hljs-string">'A'</span>&#125;,<span class="hljs-keyword">value</span>=<span class="hljs-string">'Good'</span>)<br></code></pre></td></tr></table></figure><br>　　也可以指定正则表达式进行替换，这时需要设定参数regex为True，代表to_replace部分输入的是正则表达式。如查找所有以C开头的字段并替换为Bad。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">test_loan.replace(<span class="hljs-attribute">to_replace</span>=<span class="hljs-string">'C+.*$'</span>, <span class="hljs-attribute">value</span>=<span class="hljs-string">'Bad'</span>, <span class="hljs-attribute">regex</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>　　在Pandas中，如果只是针对某一个Series进行数值替代，我们也可以使用map方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">test_loan[<span class="hljs-string">'loan_status'</span>].<span class="hljs-keyword">map</span>(&#123;<span class="hljs-string">'Fully Paid'</span>:<span class="hljs-number">0</span>,<span class="hljs-string">'Charged Off'</span>:<span class="hljs-number">0</span>,<span class="hljs-string">'In Grace Period'</span>:<span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><br>　　这同样实现了将贷款状态进行替换的效果，但map不能像replace一样直接对DataFrame进行操作。不过map不仅仅可以像上面一样输入字典作为参数，也可以直接输入一个函数进行映射。<br>　　例如，将数据中利率低于12%的映射为’Low’，高于12%的映射为’High’。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">12</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">'Low'</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">'High'</span><br>        <br>combine[<span class="hljs-string">'int_rate'</span>].map(f)<br></code></pre></td></tr></table></figure></p>
<h3 id="哑变量处理-get-dummies"><a href="#哑变量处理-get-dummies" class="headerlink" title="哑变量处理(get_dummies)"></a>哑变量处理(get_dummies)</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cat_vars=[<span class="hljs-string">'term'</span>,<span class="hljs-string">'grade'</span>,<span class="hljs-string">'emp_length'</span>,<span class="hljs-string">'annual_inc'</span>,<span class="hljs-string">'home_ownership'</span>,<span class="hljs-string">'verification_status'</span>]<br><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> cat_vars:<br>    cat_list = pd.get_dummies(combine[var], <span class="hljs-attribute">prefix</span>=var, <span class="hljs-attribute">drop_first</span>=<span class="hljs-literal">True</span>)<br>    <span class="hljs-attribute">combine</span>=combine.join(cat_list)<br></code></pre></td></tr></table></figure>
<p>　　get_dummies函数中使用了两个参数。prefix可以为新生成的哑变量添加前缀，这方便我们识别新生成的变量是从原来哪一个变量中得来的。drop_first设置为True将删去所获得哑变量的第一个，这是因为在建模中，有k类的分类变量只需要k-1个变量就可以将其描述，如果使用k个变量则会出现完全共线性的问题。<br>　　此外，在这里选择了使用join而不是merge，这是因为get_dummies返回的结果与原始数据有相同的索引，使用join直接基于索引进行连接更简洁。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pd.get<span class="hljs-constructor">_dummies(<span class="hljs-params">combine</span>['<span class="hljs-params">grade</span>'], <span class="hljs-params">prefix</span>='<span class="hljs-params">grade</span>',<span class="hljs-params">drop_first</span>=True)</span><span class="hljs-literal">[:<span class="hljs-number">5</span>]</span><br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c}
&grade\_B&    grade_C&    grade_D&    grade_E&    grade_F&    grade_G\\
\hline
0&    0&    0&    1&    0&    0&    0& \\
\hline
1&    0&    1&    0&    0&    0&    0& \\
\hline
2&    1&    0&    0&    0&    0&    0& \\ 
\hline
3&    0&    0&    0&    0&    0&    0&\\
\hline
4&    0&    1&    0&    0&    0&    0&
 \end{array}</script><p>　　如果使用merge：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">combine</span>=combine.merge(cat_list,left_index=<span class="hljs-literal">True</span>,right_index=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></p>
<h3 id="添加常数项列-concat"><a href="#添加常数项列-concat" class="headerlink" title="添加常数项列(concat)"></a>添加常数项列(concat)</h3><p>　　在回归分析中，我们往往还需要为自变量添加常数项列，值全为1。<br>　　首先创建一个长度为X的行数，值全为1的列表。再将其转化为Series，并命名”const”。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const = pd.<span class="hljs-constructor">Series([1] <span class="hljs-operator">*</span> <span class="hljs-params">combine</span>.<span class="hljs-params">shape</span>[0],<span class="hljs-params">name</span>=<span class="hljs-string">"const"</span>)</span><br></code></pre></td></tr></table></figure><br>　　重设X索引，使用concat对数据进行合并，并指定方向为列。<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">X</span>.<span class="hljs-meta">reset</span><span class="hljs-meta">_index(</span><span class="hljs-meta">drop</span>=True,inplace=True)<br><span class="hljs-meta">X</span> = pd.concat([const,<span class="hljs-meta">X</span>],axis=1)<br></code></pre></td></tr></table></figure><br>　　这里之所以要先重新设置X的索引，是因为concat是基于索引进行拼接的。这么看来，对于列的拼接其实直接使用join就可以了，不过目前join只能作为DataFrame的方法，想拼接DataFrame和Series就必须把DataFrame写在前面：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cs">X.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">const</span>)<br></code></pre></td></tr></table></figure><br>　　此外，concat更常用的是进行行的连接。concat参数如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pandas.concat(objs, <span class="hljs-attribute">axis</span>=0, <span class="hljs-attribute">join</span>=<span class="hljs-string">'outer'</span>)<br></code></pre></td></tr></table></figure><br>　　objs: Series,DataFrame等构成的list<br>　　axis: 合并连接的方向，0是行，1是列<br>　　join：连接方式，”inner”或者”outer”  </p>
<p>　　可以看到，concat的对象必须是一个list。  </p>
<p>　　创建两个dataframe:df1,df2。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">df1 = pd.<span class="hljs-symbol">DataFrame</span>([[<span class="hljs-string">'a'</span>,<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">'b'</span>,<span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>]],columns=[<span class="hljs-string">'letter'</span>,<span class="hljs-string">'letter1'</span>,<span class="hljs-string">'number'</span>])<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c}
 & letter & letter1    & number\\
\hline
0    & a    & a    & 1\\
\hline
1    & b    & b    & 2
\end{array}</script><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">df2 = pd.<span class="hljs-symbol">DataFrame</span>([[<span class="hljs-string">'c'</span>,<span class="hljs-string">'c'</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'d'</span>,<span class="hljs-string">'d'</span>, <span class="hljs-number">4</span>]],columns=[<span class="hljs-string">'letter'</span>,<span class="hljs-string">'letter2'</span>,<span class="hljs-string">'number'</span>])<br></code></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c}
& letter & letter1    & number\\
\hline
0    & c    & c    & 3\\
\hline
1    & d    & d    & 4
\end{array}</script><p>　　使用inner方式进行连接，只有能够匹配的变量才会保留。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pd.concat([df1,df2],axis=<span class="hljs-number">0</span>,join=<span class="hljs-string">'inner'</span>)<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c}
 & letter & number \\
\hline
0 &    a &    1 \\
\hline
1 &    b &    2 \\
\hline
0 &    c &    3 \\
\hline
1 &    d &    4
\end{array}</script><p>　　使用outer方式进行连接，所有变量都会保留，不能匹配的部分用缺失值填充。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pd.concat([df1,df2],axis=<span class="hljs-number">0</span>,join=<span class="hljs-string">'outer'</span>)<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c}
 & letter &    letter1 & letter2 &    number \\
\hline
0 &    a&    a&    NaN&    1 \\ 
\hline
1&    b&    b&    NaN&    2 \\ 
\hline
0&    c&    NaN&    c&    3 \\
\hline
1&    d&    NaN&d    4&
\end{array}</script><p>　　ignore_index参数为Ture将忽略原来的索引，从0开始重建索引。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pd.concat([df1,df2],<span class="hljs-attribute">ignore_index</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><br>　　通过key参数可以建立多层索引，方便识别数据来自于哪个数据源。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">pd.concat([df1,df2],keys=[<span class="hljs-string">'df1'</span>, <span class="hljs-string">'df2'</span>])<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c}
 & & letter & letter1 & letter2& number \\
\hline
df1 & 0 & a & a & NaN & 1 \\
  & 1 & b & b & NaN & 2 \\
\hline
df2 & 0 & c & NaN & c & 3 \\
  & 1 & d & NaN & d & 4 \\
\end{array}</script><h2 id="行星数据分组与聚合"><a href="#行星数据分组与聚合" class="headerlink" title="行星数据分组与聚合"></a>行星数据分组与聚合</h2><p> 　　该案例完整Jupyter Notebook可参考<a href="http://cookdata.cn/note/view_static_note/7b30c741facfb06d83bc37ae3a7fa8a3/" target="_blank" rel="noopener">行星数据分组与聚合</a>。</p>
<h3 id="数据源-1"><a href="#数据源-1" class="headerlink" title="数据源"></a>数据源</h3><p>　　行星数据集记录了2014年之前发现的行星的信息。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">planets</span> = pd.read_csv(<span class="hljs-string">"./input/planets.csv"</span>)<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c|c}
 & method&number&orbital\_period&mass&distance&year \\
\hline
0&    Radial Velocity    &1&    269.300    &7.10    &77.40    &2006 \\
\hline
1&    Radial Velocity    &1&    874.774    &2.21    &56.95    &2008 \\
\hline
2&    Radial Velocity    &1&    763.000    &2.60    &19.84    &2011 \\
\hline
3&    Radial Velocity    &1&    326.030    &19.40    &110.62    &2007 \\
\hline
4&    Radial Velocity    &1&    516.220    &10.50    &119.47    &2009
\end{array}</script><h3 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h3><h4 id="通过特征分组"><a href="#通过特征分组" class="headerlink" title="通过特征分组"></a>通过特征分组</h4><p>　　groupby可以指定某一个特征或指定某一组特征进行分组。<br>　　例如按method特征对数据进行分组。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">grouped</span> = planets.groupby(<span class="hljs-string">'method'</span>)<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;pandas<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.groupby</span><span class="hljs-selector-class">.generic</span><span class="hljs-selector-class">.DataFrameGroupBy</span> <span class="hljs-selector-tag">object</span> at <span class="hljs-number">0</span>x7f1d00504a58&gt;<br></code></pre></td></tr></table></figure><br>　　groupby还能通过指定一个与目标数据等长的array、list或Series进行分组。<br>　　例如，行星数据集共有1035条记录，生成一个长度为1035，前500都为0，后535都为1的array。<br>　　使用repeat，输入中第一部分指定了值，第二部分指定对应值的重复次数。我们将生成结果记为a。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">a = np.repeat([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">500</span>, <span class="hljs-number">535</span>])<br></code></pre></td></tr></table></figure><br>　　以其对原数据进行分组，并计算各特征的均值。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">planets</span><span class="hljs-selector-class">.groupby</span>(<span class="hljs-selector-tag">a</span>)<span class="hljs-selector-class">.mean</span>()<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c}
 &number&orbital\_period&mass&distance&year\\
\hline
0&    1.644000&    1450.908401&    2.580901&    97.615625&    2007.916000& \\
\hline
1&    1.917757&    2526.729858&    2.800112&    507.660000&    2010.149533&
\end{array}</script><h4 id="通过函数分组"><a href="#通过函数分组" class="headerlink" title="通过函数分组"></a>通过函数分组</h4><p>　　也可以通过函数进行分组。<br>　　例如，想将数据按发现年份在2000年前和2000年后进行分组。使用set_index设定year变量为数据的新索引，然后定义一个函数test，当数据小于2000时返回’Before 2000’，大于等于2000时返回’After 2000’，最后通过自定义函数test进行分组，并求各组各变量均值。<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sas">new = planets.<span class="hljs-meta">set</span><span class="hljs-meta">_index(</span><span class="hljs-string">'year'</span>)<br><br>def test(<span class="hljs-meta">x</span>):<br>    <span class="hljs-meta">if</span> <span class="hljs-meta">x</span>&lt;2000:<br>        <span class="hljs-meta">return</span> <span class="hljs-string">'Before 2000'</span><br>    <span class="hljs-meta">else</span>:<br>        <span class="hljs-meta">return</span> <span class="hljs-string">'After 2000'</span><br>        <br>new.groupby(test)<span class="hljs-meta">.mean(</span>)<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c}
 &    number&    orbital\_period&    mass&    distance\\
\hline
After 2000&    1.780658&    2058.025770&    2.615027&    272.918742&\\
\hline
Before 2000&    1.937500&    349.672379&    3.071469&    26.354483&
\end{array}</script><p>　　函数的输入是数据的索引列。以上代码相当于这样两步操作：<br>　　1. 对目标数据索引的每一个元素执行相应函数；<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">group_index = <span class="hljs-keyword">new</span>.<span class="hljs-built_in">index</span>.<span class="hljs-keyword">map</span>(test)<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Index(['After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>',<br>       'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'Before <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>',<br>       ...<br>       'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>',<br>       'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>', 'After <span class="hljs-number">2000</span>'],<br>      dtype='object', name='year', length=<span class="hljs-number">1035</span>)<br></code></pre></td></tr></table></figure><br>　　2. 以这一个新变量group_index进行分组。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">new</span><span class="hljs-selector-class">.groupby</span>(<span class="hljs-selector-tag">group_index</span>)<span class="hljs-selector-class">.mean</span>()<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c}
 &    number&    orbital\_period&    mass&    distance\\
\hline
year & & & & \\
\hline
After 2000&    1.780658&    2058.025770&    2.615027&    272.918742\\
\hline
Before 2000&    1.937500&    349.672379&    3.071469&    26.354483
\end{array}</script><h3 id="GroupBy对象的基本操作"><a href="#GroupBy对象的基本操作" class="headerlink" title="GroupBy对象的基本操作"></a>GroupBy对象的基本操作</h3><h4 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h4><p>　　groupby返回的结果是一个GroupBy类型的对象，可以使用循环查看其内部结构：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pd.set_option(<span class="hljs-string">'expand_frame_repr'</span>,<span class="hljs-literal">False</span>)<br><span class="hljs-keyword">for</span> (name,group) <span class="hljs-keyword">in</span> grouped:<br>    <span class="hljs-builtin-name">print</span>(name)<br>    <span class="hljs-builtin-name">print</span>(group.head(<span class="hljs-attribute">n</span>=2),'\n')<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso">(<span class="hljs-string">'Astrometry'</span>, <span class="hljs-number">2010</span>)<br>(<span class="hljs-string">'Astrometry'</span>, <span class="hljs-number">2013</span>)<br>(<span class="hljs-string">'Eclipse Timing Variations'</span>, <span class="hljs-number">2008</span>)<br>(<span class="hljs-string">'Eclipse Timing Variations'</span>, <span class="hljs-number">2009</span>)<br>(<span class="hljs-string">'Eclipse Timing Variations'</span>, <span class="hljs-number">2010</span>)<br>(<span class="hljs-string">'Eclipse Timing Variations'</span>, <span class="hljs-number">2011</span>)<br>(<span class="hljs-string">'Eclipse Timing Variations'</span>, <span class="hljs-number">2012</span>)<br>(<span class="hljs-string">'Imaging'</span>, <span class="hljs-number">2004</span>)<br>(<span class="hljs-string">'Imaging'</span>, <span class="hljs-number">2005</span>)<br>(<span class="hljs-string">'Imaging'</span>, <span class="hljs-number">2006</span>)<br>(<span class="hljs-string">'Imaging'</span>, <span class="hljs-number">2007</span>)<br><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><br>　　GroupBy类型的对象是由各组组名与其对应的分组数据构成。这里只依据method一个特征进行了分组，若基于多个特征进行分组，则返回的GroupBy的组名会是一个多元元组。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> (name,group) <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">planets</span><span class="hljs-selector-class">.groupby</span>([<span class="hljs-string">'method'</span>,<span class="hljs-string">'year'</span>]):<br>    <span class="hljs-selector-tag">print</span>(name)<br></code></pre></td></tr></table></figure><br>　　GroupBy内部是由一个个DataFrame组成，可以在循环中对每组数据进行操作。<br>　　例如，对每组数据使用shape。为了使输出更美观，我们使用format指定了输出的字符串格式，第一个{0:30s}匹配format中第一个字符串method，并指定字符串长度为30；第二个{1}匹配format中第二个字符串group.shape。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">method</span>, <span class="hljs-keyword">group</span>) <span class="hljs-keyword">in</span> planets.groupby(<span class="hljs-string">'method'</span>):<br>    print("&#123;0:30s&#125; shape=&#123;1&#125;".format(<span class="hljs-keyword">method</span>, <span class="hljs-keyword">group</span>.shape))<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Astrometry                     shape=(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)<br>Eclipse Timing Variations      shape=(<span class="hljs-number">9</span>, <span class="hljs-number">6</span>)<br>Imaging                        shape=(<span class="hljs-number">38</span>, <span class="hljs-number">6</span>)<br>Microlensing                   shape=(<span class="hljs-number">23</span>, <span class="hljs-number">6</span>)<br>Orbital Brightness Modulation  shape=(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)<br>Pulsar Timing                  shape=(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>Pulsation Timing Variations    shape=(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br>Radial Velocity                shape=(<span class="hljs-number">553</span>, <span class="hljs-number">6</span>)<br>Transit                        shape=(<span class="hljs-number">397</span>, <span class="hljs-number">6</span>)<br>Transit Timing Variations      shape=(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><br>　　也有一些可以直接对GroupBy使用的方法，例如size方法可以查看每个分组的数据量。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">grouped.<span class="hljs-built_in">size</span>()<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">method<br>Astrometry                         <span class="hljs-number">2</span><br>Eclipse Timing Variations          <span class="hljs-number">9</span><br>Imaging                           <span class="hljs-number">38</span><br>Microlensing                      <span class="hljs-number">23</span><br>Orbital Brightness Modulation      <span class="hljs-number">3</span><br>Pulsar Timing                      <span class="hljs-number">5</span><br>Pulsation Timing Variations        <span class="hljs-number">1</span><br>Radial Velocity                  <span class="hljs-number">553</span><br>Transit                          <span class="hljs-number">397</span><br>Transit Timing Variations          <span class="hljs-number">4</span><br>dtype: <span class="hljs-built_in">int</span>64<br></code></pre></td></tr></table></figure></p>
<h4 id="选择指定特征分析"><a href="#选择指定特征分析" class="headerlink" title="选择指定特征分析"></a>选择指定特征分析</h4><p>　　针对GroupBy类型的对象，我们可以直接选取出需要的列。例如，取出year特征。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grouped</span><span class="hljs-selector-attr">[<span class="hljs-string">'year'</span>]</span><br></code></pre></td></tr></table></figure><br>　　这仍然是一个GroupBy类型的对象，但和之前的结果相比，这是一个SeriesGroupBy，而之前的是一个DataFrameGroupBy。<br>　　对于这种类型，可以直接使用一些聚合函数（如sum、mean、max、min…）。例如，查看不同方法发现的行星与地球距离的中位数：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">planets</span><span class="hljs-selector-class">.groupby</span>(<span class="hljs-string">'method'</span>)<span class="hljs-selector-attr">['distance']</span><span class="hljs-selector-class">.median</span>()<br></code></pre></td></tr></table></figure><br>　　也可以直接使用describe。例如查看不同方法发现行星的时间情况。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grouped</span><span class="hljs-selector-attr">[<span class="hljs-string">'year'</span>]</span><span class="hljs-selector-class">.describe</span>()<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c}
 & count & mean & std & min & 25\% & 50\% & 75\% & max \\
\hline
method\\
\hline
Astrometry    &2.0&2011.500000&2.121320&2010.0&2010.75&2011.5&2012.25&2013.0\\
\hline
...
\end{array}</script><h4 id="结合分组方法与聚合函数分析"><a href="#结合分组方法与聚合函数分析" class="headerlink" title="结合分组方法与聚合函数分析"></a>结合分组方法与聚合函数分析</h4><p>　　首先将年份按每10年进行划分。通过//将年份整除10（向下取整），再乘以10，可以将年份变换为对应年代。再使用astype将类型转换为字符串并加上’s’代表对应年代。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">decade</span> = <span class="hljs-number">10</span> * (planets[<span class="hljs-string">'year'</span>] // <span class="hljs-number">10</span>)<br><span class="hljs-attr">decade</span> = decade.astype(str) + <span class="hljs-string">'s'</span><br></code></pre></td></tr></table></figure><br>　　按发现行星的方法和发现的年代进行分组，并统计相应分组下发现的行星的总数。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">planets</span><span class="hljs-selector-class">.groupby</span>(<span class="hljs-selector-attr">[<span class="hljs-string">'method'</span>, decade]</span>)<span class="hljs-selector-attr">[<span class="hljs-string">'number'</span>]</span><span class="hljs-selector-class">.sum</span>()<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">method						year <br>Astrometry					<span class="hljs-number">2010</span>s      <span class="hljs-number">2</span><br>Eclipse Timing Variations	<span class="hljs-number">2000</span>s      <span class="hljs-number">5</span><br>							<span class="hljs-number">2010</span>s     <span class="hljs-number">10</span><br>Imaging						<span class="hljs-number">2000</span>s     <span class="hljs-number">29</span><br> 							<span class="hljs-number">2010</span>s     <span class="hljs-number">21</span><br>...<br></code></pre></td></tr></table></figure><br>　　使用unstack将按层次化索引拆开为新的列索引。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">planets</span><span class="hljs-selector-class">.groupby</span>(<span class="hljs-selector-attr">[<span class="hljs-string">'method'</span>, decade]</span>)<span class="hljs-selector-attr">[<span class="hljs-string">'number'</span>]</span><span class="hljs-selector-class">.sum</span>()<span class="hljs-selector-class">.unstack</span>()<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c}
year&1980s&1990s&2000s&2010s \\
\hline
method \\
\hline
Astrometry&NaN&NaN&NaN&2.0 \\
\hline
Eclipse Timing Variations&NaN&NaN&5.0&10.0\\
\hline
...
\end{array}</script><h3 id="GroupBy-apply"><a href="#GroupBy-apply" class="headerlink" title="GroupBy.apply"></a>GroupBy.apply</h3><p>　　apply方法能够分别对每一份分组数据进行对应的函数操作，再合并成一个数据表。因此，apply中使用的函数必须是以DataFrame作为输入的，而且每一个apply语句只能传入一个函数。<br>　　例如：使用apply计算不同方法发现的行星在各特征上的极差(最大值与最小值之差)。<br><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">grouped.apply(lambda <span class="hljs-symbol">x</span>: <span class="hljs-symbol">x</span>.<span class="hljs-built_in">max</span>() - <span class="hljs-symbol">x</span>.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c}
 &number&orbital\_period&mass&distance&year\\
\hline
method \\
\hline
Astrometry&    0.0&769.640000&NaN&5.79    &3.0 \\
\hline
Eclipse Timing Variations&1.0&8303.750000&1.8500&369.28    &4.0 \\
\hline
...
\end{array}</script><p>　　此例中，每一组数据返回了一个Series。apply应用的函数也可以只返回一个标量，例如计算每种方法发现的行星中和地球距离的最大值与轨道周期的最大值之比。<br><strong><em>Output:</em></strong><br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-function"><span class="hljs-keyword">method</span></span><br><span class="hljs-function"><span class="hljs-title">Astrometry</span>                         0.020443</span><br><span class="hljs-function"><span class="hljs-title">Eclipse</span> <span class="hljs-title">Timing</span> <span class="hljs-title">Variations</span>          0.048924</span><br><span class="hljs-function"><span class="hljs-title">Imaging</span>                            0.000226</span><br><span class="hljs-function"><span class="hljs-title">Microlensing</span>                       1.513725</span><br><span class="hljs-function"><span class="hljs-title">Orbital</span> <span class="hljs-title">Brightness</span> <span class="hljs-title">Modulation</span>    763.789269</span><br><span class="hljs-function"><span class="hljs-title">Pulsar</span> <span class="hljs-title">Timing</span>                      0.032854</span><br><span class="hljs-function"><span class="hljs-title">Pulsation</span> <span class="hljs-title">Timing</span> <span class="hljs-title">Variations</span>             <span class="hljs-title">NaN</span></span><br><span class="hljs-function"><span class="hljs-title">Radial</span> <span class="hljs-title">Velocity</span>                    0.020418</span><br><span class="hljs-function"><span class="hljs-title">Transit</span>                           25.633248</span><br><span class="hljs-function"><span class="hljs-title">Transit</span> <span class="hljs-title">Timing</span> <span class="hljs-title">Variations</span>         13.243750</span><br><span class="hljs-function"><span class="hljs-title">dtype</span>:</span> float64<br></code></pre></td></tr></table></figure><br>　　apply应用的函数也可以返回一个DataFrame。例如分组中心化数据。<br><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">grouped.apply(lambda <span class="hljs-symbol">x</span>: <span class="hljs-symbol">x</span>-<span class="hljs-symbol">x</span>.<span class="hljs-built_in">mean</span>())<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c|c}
    &distance&    mass&    method&    number&    orbital\_period&    year\\
\hline
0&    25.799792&    4.469301&    NaN&    -0.721519&    -554.05468&    -1.518987\\
\hline
1&    5.349792&    -0.420699&    NaN&    -0.721519&    51.41932&    0.481013\\
\hline
...
\end{array}</script><p>　　当apply中运用的函数除了输入的DataFrame外还有其他参数时，直接在apply中进行赋值即可。例如查看按method分组后各组数据的前两行。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func1</span><span class="hljs-params">(x,n)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-keyword">return</span>(x.head(n))<br>grouped.apply(func1,n=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><br>　　apply的运行实际过程有分开运算、结果合并两步，因此，在数据量较大时，apply的运行速度会比可以实现同样操作的其他方法要慢。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">%timeit grouped.<span class="hljs-built_in">apply</span>(<span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>)<br></code></pre></td></tr></table></figure><br><em>16.1 ms ± 50.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</em><br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">timeit</span></span> grouped.mean()<br></code></pre></td></tr></table></figure><br><em>624 µs ± 337 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)</em>  </p>
<p>　　总结来看，apply方法只需要传入的函数的输入为DataFrame即可，函数的输出可以是标量、Series或DataFrame。但必须以DataFrame为输入就会导致当我们想对不同特征分别进行操作时比较麻烦。例如，分别计算各种方法发现的行星的距离的均值和发现的数量之和。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func2</span><span class="hljs-params">(df)</span></span><span class="hljs-symbol">:</span><br>    mean_distance = np.mean(df[<span class="hljs-string">'distance'</span>])<br>    sum_number = np.sum(df[<span class="hljs-string">'number'</span>])<br>    <span class="hljs-keyword">return</span>(pd.Series(&#123;<span class="hljs-string">'mean_distance'</span><span class="hljs-symbol">:mean_distance</span>,<span class="hljs-string">'sum_number'</span><span class="hljs-symbol">:sum_number</span>&#125;))<br><br>grouped.apply(func2)<br></code></pre></td></tr></table></figure></p>
<h3 id="GroupBy-agg"><a href="#GroupBy-agg" class="headerlink" title="GroupBy.agg"></a>GroupBy.agg</h3><p>　　同样，分别计算各种方法发现的行星的距离的均值和发现的数量之和。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">grouped.agg(&#123;'distance':'mean','number':'sum'&#125;)<br></code></pre></td></tr></table></figure><br>　　这里使用“变量名:函数名”的形式向agg传入一个字典。agg方法可以针对某个特征同时执行多个函数。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">grouped.agg(&#123;<span class="hljs-string">'distance'</span>:[<span class="hljs-string">'min'</span>,<span class="hljs-string">'max'</span>,<span class="hljs-string">'mean'</span>,<span class="hljs-string">'median'</span>],<span class="hljs-string">'number'</span>:<span class="hljs-string">'sum'</span>&#125;)<br></code></pre></td></tr></table></figure><br>　　agg方法中同样可以使用自定义函数，例如求极差：<br><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">grouped.agg(lambda <span class="hljs-symbol">x</span>: <span class="hljs-symbol">x</span>.<span class="hljs-built_in">max</span>()-<span class="hljs-symbol">x</span>.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><br>　　需要注意，尽管这里使用agg和apply获得了相同的结果，但是，在apply中是对每一组数据整个DataFrame进行一次运算，而在agg中将对每一组数据中的每一个特征进行运算。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span><span class="hljs-params">(x)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-keyword">return</span>(x.shape)<br></code></pre></td></tr></table></figure><br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">grouped.<span class="hljs-built_in">apply</span>(test2)<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-function"><span class="hljs-keyword">method</span></span><br><span class="hljs-function"><span class="hljs-title">Astrometry</span>                         <span class="hljs-params">(2, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Eclipse</span> <span class="hljs-title">Timing</span> <span class="hljs-title">Variations</span>          <span class="hljs-params">(9, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Imaging</span>                           <span class="hljs-params">(38, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Microlensing</span>                      <span class="hljs-params">(23, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Orbital</span> <span class="hljs-title">Brightness</span> <span class="hljs-title">Modulation</span>      <span class="hljs-params">(3, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Pulsar</span> <span class="hljs-title">Timing</span>                      <span class="hljs-params">(5, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Pulsation</span> <span class="hljs-title">Timing</span> <span class="hljs-title">Variations</span>        <span class="hljs-params">(1, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Radial</span> <span class="hljs-title">Velocity</span>                  <span class="hljs-params">(553, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Transit</span>                          <span class="hljs-params">(397, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">Transit</span> <span class="hljs-title">Timing</span> <span class="hljs-title">Variations</span>          <span class="hljs-params">(4, 6)</span></span><br><span class="hljs-function"><span class="hljs-title">dtype</span>:</span> object<br></code></pre></td></tr></table></figure><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grouped</span><span class="hljs-selector-class">.agg</span>(<span class="hljs-selector-tag">test2</span>)<br></code></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c|c}
    & number&    orbital\_period    & mass & distance &    year \\
\hline
method \\
\hline
Astrometry&    (2,)&    (2,)&    (2,)&    (2,)&    (2,)\\
\hline
Eclipse Timing Variations&    (9,)&    (9,)&    (9,)&    (9,)&    (9,)\\
\hline
...
\end{array}</script><p>　　可以看到，apply返回的是每一组数据的维度，而agg返回的是每组数据下，每一个特征对应的数据的维度。因此，我们可以将agg的操作分为3步：<br>　　1. 对每组数据中的每一列执行函数;<br>　　2. 将每一列返回结果合并;<br>　　3. 将每一组数据返回结果合并<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">%timeit</span> grouped.apply(lambda <span class="hljs-keyword">x</span>: <span class="hljs-keyword">x</span>.<span class="hljs-keyword">max</span>()-<span class="hljs-keyword">x</span>.<span class="hljs-keyword">min</span>())<br></code></pre></td></tr></table></figure><br><em>32.2 ms ± 28.9 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</em><br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">%timeit</span> grouped.agg(lambda <span class="hljs-keyword">x</span>:<span class="hljs-keyword">x</span>.<span class="hljs-keyword">max</span>()-<span class="hljs-keyword">x</span>.<span class="hljs-keyword">min</span>())<br></code></pre></td></tr></table></figure><br><em>19.6 ms ± 7.73 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</em>  </p>
<p>　　因此，尽管相比于apply，agg可以从更细的维度进行数据处理，但也意味着更多的运算消耗。同时，agg方法对使用的函数的返回也有一定要求：对每一个特征，函数只能返回一个标量。例如，使用apply进行中心化的操作无法使用agg完成。<br><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">grouped.agg(lambda <span class="hljs-symbol">x</span>: <span class="hljs-symbol">x</span>-<span class="hljs-symbol">x</span>.<span class="hljs-built_in">mean</span>())<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ValueError: Shape of passed values <span class="hljs-keyword">is</span> (<span class="hljs-number">6</span>, <span class="hljs-number">10</span>), indices imply (<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></p>
<h3 id="GroupBy-transform"><a href="#GroupBy-transform" class="headerlink" title="GroupBy.transform"></a>GroupBy.transform</h3><p>　　transform方法中传入的函数只能返回两种结果，可以广播的标量值或者与分组数据维度相同的数据。<br>　　对分组数据求均值，然后把这个均值赋值给整个组（可广播的标量值）。</p>
<script type="math/tex; mode=display">
\begin{array}{c|c|c|c|c|c}
 & number&    orbital\_period&    mass&    distance&    year \\
\hline
0&    1.721519&    823.35468&    2.630699&    51.600208&    2007.518987\\
\hline
1&    1.721519&    823.35468&    2.630699&    51.600208&    2007.518987\\
\hline
...
\end{array}</script><p> 　　使用<code>transform</code>实现分组数据标准化($\dfrac{x-\bar{x}}{s}$)(分组数据维度相同的数据):<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">grouped.transform(lambda <span class="hljs-meta">x</span>: (<span class="hljs-meta">x</span> - <span class="hljs-meta">x</span><span class="hljs-meta">.mean(</span>)) / <span class="hljs-meta">x</span><span class="hljs-meta">.std(</span>))<br></code></pre></td></tr></table></figure></p>
<p>　　apply中自定义函数对每个分组数据单独进行处理，再将结果合并；整个DataFrame的函数输出可以是标量、Series或DataFrame；每个apply语句只能传入一个函数；<br>　　agg可以通过字典方式指定特征进行不同的函数操作，每一特征的函数输出必须为标量；<br>　　transform不可以通过字典方式指定特征进行不同的函数操作，但函数运算单位也是DataFrame的每一特征，每一特征的函数输出可以是标量或者Series，但标量会被广播。  </p>
<h2 id="德国能源数据时间序列分析"><a href="#德国能源数据时间序列分析" class="headerlink" title="德国能源数据时间序列分析"></a>德国能源数据时间序列分析</h2><p> 　　该案例完整Jupyter Notebook可参考<a href="http://cookdata.cn/note/view_static_note/abdeedf821256e7ffacffe03f68e4cf2/" target="_blank" rel="noopener">德国能源数据时间序列分析</a>。</p>
<h3 id="数据源-2"><a href="#数据源-2" class="headerlink" title="数据源"></a>数据源</h3><p>　　数据的字段及其说明如下： </p>
<script type="math/tex; mode=display">
\begin{array}{c|c}
变量名称&含义说明 \\
\hline
Date&日期 \\
\hline
Consumption&电力消耗 \\
\hline
Wind&风能发电量 \\
\hline
Solar&太阳能发电量
\end{array}</script><p>　　使用dtypes查看数据类型。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">opsd</span><span class="hljs-selector-class">.dtypes</span><br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nimrod"><span class="hljs-type">Date</span>           datetime64[ns]<br><span class="hljs-type">Consumption</span>           <span class="hljs-built_in">float64</span><br><span class="hljs-type">Wind</span>                  <span class="hljs-built_in">float64</span><br><span class="hljs-type">Solar</span>                 <span class="hljs-built_in">float64</span><br><span class="hljs-type">Wind</span>+<span class="hljs-type">Solar</span>            <span class="hljs-built_in">float64</span><br>dtype: <span class="hljs-keyword">object</span><br></code></pre></td></tr></table></figure><br>　　使用set_index将Date变量设定为索引。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">opsd.set_index(<span class="hljs-string">'Date'</span>,<span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><br>　　也可以在数据导入时通过参数设置实现这些操作。设定index_col为0即以数据中第一列为索引，设定parse_dates为True，会把索引识别为时间数据类型。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">opsd = pd.read<span class="hljs-constructor">_csv('.<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">opsd_germany_daily</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">index_col</span>=0, <span class="hljs-params">parse_dates</span>=True)</span><br></code></pre></td></tr></table></figure><br>　　查看此时索引格式。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">opsd.<span class="hljs-keyword">index</span><br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lsl">DatetimeIndex(['<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>',<br>               '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-06</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-07</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-08</span>',<br>               '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-09</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-10</span>',<br>               ...<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-22</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-23</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-24</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-25</span>',<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-28</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-29</span>',<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>'],<br>              dtype='datetime64[ns]', name='Date', length=<span class="hljs-number">4383</span>, freq=None)<br></code></pre></td></tr></table></figure><br>　　可以使用asfreq进行指定。如果数据中缺失了某个时间，asfreq将自动为这些时间添加新行，并默认分配空值。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">opsd = opsd.asfre<span class="hljs-string">q('D')</span><br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lsl">DatetimeIndex(['<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>',<br>               '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-06</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-07</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-08</span>',<br>               '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-09</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-10</span>',<br>               ...<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-22</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-23</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-24</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-25</span>',<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-28</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-29</span>',<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>'],<br>              dtype='datetime64[ns]', name='Date', length=<span class="hljs-number">4383</span>, freq='D')<br></code></pre></td></tr></table></figure></p>
<h3 id="基于时间索引筛选数据"><a href="#基于时间索引筛选数据" class="headerlink" title="基于时间索引筛选数据"></a>基于时间索引筛选数据</h3><p>　　对于时间数据索引，可以使用loc提取数据。例如，查找2017年8月10日的数据。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">opsd</span><span class="hljs-selector-class">.loc</span><span class="hljs-selector-attr">[<span class="hljs-string">'2017-08-10'</span>]</span><br></code></pre></td></tr></table></figure><br>　　也可以选择一段时间，例如2014年1月20日至2014年1月22日的数据。与使用loc的常规索引一样，切片将包含两个端点。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">opsd.loc['<span class="hljs-number">2014-01-20</span>':'<span class="hljs-number">2014-01-22</span>']<br></code></pre></td></tr></table></figure><br>　　可以不具体到日，而仅仅指定对应的年和月，将返回当月的所有数据。例如，查找2017年1月份的数据。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">opsd</span><span class="hljs-selector-class">.loc</span><span class="hljs-selector-attr">[<span class="hljs-string">'2017-01'</span>]</span><br></code></pre></td></tr></table></figure><br>　　获取时间范围内的数据也可以使用truncate进行筛选。before将删去给定日期之前的数据，after将删去给定日期之后的数据。例如，筛选2017年1月份的数据。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl">opsd.truncate(before='<span class="hljs-number">2017</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>',after='<span class="hljs-number">2017</span><span class="hljs-number">-01</span><span class="hljs-number">-31</span>')<br></code></pre></td></tr></table></figure></p>
<h3 id="时间数据基本操作"><a href="#时间数据基本操作" class="headerlink" title="时间数据基本操作"></a>时间数据基本操作</h3><p>　　针对时间数据，可以使用year，month，weekday等多种方法获取对应时间的年份、月份和星期。<br>　　首先使用index提取数据的索引。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">opsdtime</span> = opsd.index<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lsl">DatetimeIndex(['<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>',<br>               '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-06</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-07</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-08</span>',<br>               '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-09</span>', '<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-10</span>',<br>               ...<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-22</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-23</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-24</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-25</span>',<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-28</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-29</span>',<br>               '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span>', '<span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>'],<br>              dtype='datetime64[ns]', name='Date', length=<span class="hljs-number">4383</span>, freq='D')<br></code></pre></td></tr></table></figure><br>　　使用year提取每个数据对应的年份。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">opsdtime.<span class="hljs-built_in">year</span><br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Int64Index([<span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2006</span>,<br>            ...<br>            <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2017</span>],<br>           dtype=<span class="hljs-string">'int64'</span>, name=<span class="hljs-string">'Date'</span>, length=<span class="hljs-number">4383</span>)<br></code></pre></td></tr></table></figure><br>　　使用month提取月份。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">opsdtime.<span class="hljs-built_in">month</span><br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Int64Index([ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,<br>            ...<br>            <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>],<br>           dtype=<span class="hljs-string">'int64'</span>, name=<span class="hljs-string">'Date'</span>, length=<span class="hljs-number">4383</span>)<br></code></pre></td></tr></table></figure><br>　　month返回的是对应月份的数字，若想要获得月份的名字可以使用month_name。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">opsdtime</span><span class="hljs-selector-class">.month_name</span>()<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Index([<span class="hljs-string">'January'</span>, <span class="hljs-string">'January'</span>, <span class="hljs-string">'January'</span>, <span class="hljs-string">'January'</span>, <span class="hljs-string">'January'</span>, <span class="hljs-string">'January'</span>,<br>       <span class="hljs-string">'January'</span>, <span class="hljs-string">'January'</span>, <span class="hljs-string">'January'</span>, <span class="hljs-string">'January'</span>,<br>       <span class="hljs-built_in">..</span>.<br>       <span class="hljs-string">'December'</span>, <span class="hljs-string">'December'</span>, <span class="hljs-string">'December'</span>, <span class="hljs-string">'December'</span>, <span class="hljs-string">'December'</span>, <span class="hljs-string">'December'</span>,<br>       <span class="hljs-string">'December'</span>, <span class="hljs-string">'December'</span>, <span class="hljs-string">'December'</span>, <span class="hljs-string">'December'</span>],<br>      <span class="hljs-attribute">dtype</span>=<span class="hljs-string">'object'</span>, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Date'</span>, <span class="hljs-attribute">length</span>=4383)<br></code></pre></td></tr></table></figure><br>　　可以使用weekday和weekday_name（新版本API已修改为<code>day_name()</code>）查看日期是星期几。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">opsdtime.<span class="hljs-built_in">weekday</span><br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Int64Index([<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>            ...<br>            <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>           dtype=<span class="hljs-string">'int64'</span>, name=<span class="hljs-string">'Date'</span>, length=<span class="hljs-number">4383</span>)<br></code></pre></td></tr></table></figure><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">opsdtime</span><span class="hljs-selector-class">.weekday_name</span><br># <span class="hljs-selector-tag">opsdtime</span><span class="hljs-selector-class">.day_name</span>()<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Index([<span class="hljs-string">'Sunday'</span>, <span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>,<br>       <span class="hljs-string">'Saturday'</span>, <span class="hljs-string">'Sunday'</span>, <span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>,<br>       <span class="hljs-built_in">..</span>.<br>       <span class="hljs-string">'Friday'</span>, <span class="hljs-string">'Saturday'</span>, <span class="hljs-string">'Sunday'</span>, <span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>,<br>       <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>, <span class="hljs-string">'Saturday'</span>, <span class="hljs-string">'Sunday'</span>],<br>      <span class="hljs-attribute">dtype</span>=<span class="hljs-string">'object'</span>, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Date'</span>, <span class="hljs-attribute">length</span>=4383)<br></code></pre></td></tr></table></figure><br>　　构建月份与对应季节间的映射字典。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">seasons = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br>month_to_season = dict(zip(range(<span class="hljs-number">1</span>,<span class="hljs-number">13</span>), seasons))<br><br>opsdtime.month.map(month_to_season)<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">1</span>, <span class="hljs-number">3</span>: <span class="hljs-number">2</span>, <span class="hljs-number">4</span>: <span class="hljs-number">2</span>, <span class="hljs-number">5</span>: <span class="hljs-number">2</span>, <span class="hljs-number">6</span>: <span class="hljs-number">3</span>, <span class="hljs-number">7</span>: <span class="hljs-number">3</span>, <span class="hljs-number">8</span>: <span class="hljs-number">3</span>, <span class="hljs-number">9</span>: <span class="hljs-number">4</span>, <span class="hljs-number">10</span>: <span class="hljs-number">4</span>, <span class="hljs-number">11</span>: <span class="hljs-number">4</span>, <span class="hljs-number">12</span>: <span class="hljs-number">1</span>&#125;<br><br>Int64Index([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>            ...<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>           dtype=<span class="hljs-string">'int64'</span>, name=<span class="hljs-string">'Date'</span>, length=<span class="hljs-number">4383</span>)<br></code></pre></td></tr></table></figure></p>
<h3 id="周期性分析"><a href="#周期性分析" class="headerlink" title="周期性分析"></a>周期性分析</h3><h4 id="重采样分析周期性"><a href="#重采样分析周期性" class="headerlink" title="重采样分析周期性"></a>重采样分析周期性</h4><p>　　使用plot查看数据整体情况，电力消耗总量：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">opsd[<span class="hljs-string">'Consumption'</span>].plot(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><br>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc523cae48.png" srcset="/img/loading.gif" lazyload alt="电力消耗整体情况"><br>　　具体查看2007年的数据。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">opsd.loc['<span class="hljs-number">2007</span>','Consumption'].plot(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><br>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc5007e668.png" srcset="/img/loading.gif" lazyload alt="2007年电力消耗情况"><br>　　使用groupby按变量season分组，并计算每个季节的用电量均值。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">opsd</span><span class="hljs-selector-class">.groupby</span>(<span class="hljs-string">'season'</span>)<span class="hljs-selector-attr">['Consumption']</span><span class="hljs-selector-class">.mean</span>()<span class="hljs-selector-class">.plot</span>()<br></code></pre></td></tr></table></figure><br>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff8acc0.png" srcset="/img/loading.gif" lazyload alt="按season分组均值"><br>　　使用groupby进行重采样，将数据按是星期几进行分组，并计算每组的用电量均值。这里使用lambda函数传入weekday进行分组。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">opsd</span><span class="hljs-selector-class">.groupby</span>(<span class="hljs-selector-tag">lambda</span> <span class="hljs-selector-tag">x</span><span class="hljs-selector-pseudo">:x.weekday)</span><span class="hljs-selector-attr">[<span class="hljs-string">'Consumption'</span>]</span><span class="hljs-selector-class">.mean</span>()<span class="hljs-selector-class">.plot</span>()<br></code></pre></td></tr></table></figure><br>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff1a5f8.png" srcset="/img/loading.gif" lazyload alt="按dayofweek分组均值"><br>　　使用resample对风能发电数据进行降采样。按每个月重采样，并计算每月的均值。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">wind</span> = opsd['<span class="hljs-keyword">Wind</span>'].resample('<span class="hljs-keyword">M</span>').<span class="hljs-keyword">mean</span>()<br><span class="hljs-keyword">wind</span>.<span class="hljs-keyword">plot</span>(figsize=(12,6))<br></code></pre></td></tr></table></figure><br>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e11ae48.png" srcset="/img/loading.gif" lazyload alt="按月重采样均值"></p>
<h4 id="数据差分分析周期性"><a href="#数据差分分析周期性" class="headerlink" title="数据差分分析周期性"></a>数据差分分析周期性</h4><p>　　在分析周期性的过程中，很重要的一点就是要消除数据的趋势性，常见的消除数据趋势的方法就是差分：计算连续数据点间的差异（这里特指一阶差分）。例如，t时刻的差分值：$\Delta d_t=d_t - d_{t-1}$。可以使用diff方法实现差分操作。<br>　　例如，计算太阳能发电的差分序列并绘图：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">opsd[<span class="hljs-string">'Solar'</span>].diff<span class="hljs-comment">()</span>.plot<span class="hljs-comment">(figsize=(12,6)</span>)<br></code></pre></td></tr></table></figure><br>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e0e3fd0.png" srcset="/img/loading.gif" lazyload alt="一阶差分序列"><br>　　也可以通过移动时间序列自行计算差分值。<br>　　移动序列可以使用shift方法。shift方法可以沿着时间轴将数据前移或后移，保持索引不变。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">opsd</span><span class="hljs-selector-attr">[<span class="hljs-string">'Solar'</span>]</span><span class="hljs-selector-class">.tail</span>()<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Date</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span>    <span class="hljs-number">16.530</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-28</span>    <span class="hljs-number">14.162</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-29</span>    <span class="hljs-number">29.854</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span>     <span class="hljs-number">7.467</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>    <span class="hljs-number">19.980</span><br><span class="hljs-attr">Freq:</span> <span class="hljs-string">D,</span> <span class="hljs-attr">Name:</span> <span class="hljs-string">Solar,</span> <span class="hljs-attr">dtype:</span> <span class="hljs-string">float64</span><br></code></pre></td></tr></table></figure><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">opsd</span><span class="hljs-selector-attr">[<span class="hljs-string">'Solar'</span>]</span><span class="hljs-selector-class">.shift</span>(1)<span class="hljs-selector-class">.tail</span>()<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Date</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span>    <span class="hljs-number">30.923</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-28</span>    <span class="hljs-number">16.530</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-29</span>    <span class="hljs-number">14.162</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span>    <span class="hljs-number">29.854</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>     <span class="hljs-number">7.467</span><br><span class="hljs-attr">Freq:</span> <span class="hljs-string">D,</span> <span class="hljs-attr">Name:</span> <span class="hljs-string">Solar,</span> <span class="hljs-attr">dtype:</span> <span class="hljs-string">float64</span><br></code></pre></td></tr></table></figure><br>　　两个序列相减即可得到原始数据的一阶差分序列。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">dif = opsd[<span class="hljs-string">'Solar'</span>]-opsd[<span class="hljs-string">'Solar'</span>].shift<span class="hljs-comment">(1)</span><br>dif.plot<span class="hljs-comment">(figsize=(12,6)</span>)<br></code></pre></td></tr></table></figure><br>　　也可以通过设定shift方法中的参数freq移动索引而数据保持不变，例如指定时间移动一天。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">opsd</span><span class="hljs-selector-attr">['Solar']</span><span class="hljs-selector-class">.shift</span>(<span class="hljs-number">1</span>,freq=<span class="hljs-string">'d'</span>)<span class="hljs-selector-class">.tail</span>()<br></code></pre></td></tr></table></figure><br><strong><em>Output:</em></strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Date</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-28</span>    <span class="hljs-number">16.530</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-29</span>    <span class="hljs-number">14.162</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span>    <span class="hljs-number">29.854</span><br><span class="hljs-number">2017</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>     <span class="hljs-number">7.467</span><br><span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>    <span class="hljs-number">19.980</span><br><span class="hljs-attr">Freq:</span> <span class="hljs-string">D,</span> <span class="hljs-attr">Name:</span> <span class="hljs-string">Solar,</span> <span class="hljs-attr">dtype:</span> <span class="hljs-string">float64</span><br></code></pre></td></tr></table></figure></p>
<h3 id="滚动窗口"><a href="#滚动窗口" class="headerlink" title="滚动窗口"></a>滚动窗口</h3><p>　　与降采样类似，滚动窗口将数据拆分为时间窗口，并且对每个窗口中的数据使用诸如mean，median等函数进行聚合。但是，与降采样不同，滚动窗口以与数据相同的频率重叠和“滚动”，因此变换的时间序列与原始时间序列的频率相同。<br>　　例如，设定窗口为7天，且以数据中心为基准点，则每一个数据对应的窗口将包含前面三天与后面三天。具体来看，2017-07-06对应的窗口就是2017-07-03到2017-07-09。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">opsd['Wind']<span class="hljs-string">.rolling</span><span class="hljs-params">(7)</span><span class="hljs-string">.mean</span><span class="hljs-params">()</span><span class="hljs-string">.plot</span><span class="hljs-params">(<span class="hljs-attr">figsize</span>=(12,6)</span>)<br></code></pre></td></tr></table></figure><br>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4fcae400.png" srcset="/img/loading.gif" lazyload alt="7天滑窗均值"></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">opsd['Wind']<span class="hljs-string">.rolling</span><span class="hljs-params">(30)</span><span class="hljs-string">.mean</span><span class="hljs-params">()</span><span class="hljs-string">.plot</span><span class="hljs-params">(<span class="hljs-attr">figsize</span>=(12,6)</span>)<br></code></pre></td></tr></table></figure>
<p>　　当窗口范围中存在缺失值时，窗口将会返回为缺失值，可以设定min_periods为360，只需要对应窗口中有360个以上数据就可以，这样可以容忍一小部分的缺失数据。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">opsd['Wind']<span class="hljs-string">.rolling</span><span class="hljs-params">(<span class="hljs-attr">window</span>=365,<span class="hljs-attr">min_periods</span>=360)</span><span class="hljs-string">.mean</span><span class="hljs-params">()</span><span class="hljs-string">.plot</span><span class="hljs-params">(<span class="hljs-attr">figsize</span>=(12,6)</span>)<br></code></pre></td></tr></table></figure><br>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ddfe080.png" srcset="/img/loading.gif" lazyload alt="365天滑窗均值"></p>
<h2 id="K-means-clustering-algorithm"><a href="#K-means-clustering-algorithm" class="headerlink" title="K-means clustering algorithm"></a>K-means clustering algorithm</h2><p>　　一个简单的算法伪代码描述如下：</p>
<script type="math/tex; mode=display">
\begin{aligned} 
\hline
&1:\ 选择K个点作为初始质心。\\
&2:\ repeat \\
&3:\ \quad 将每个点指派到最近的质心，形成K个簇。\\
&4:\ \quad 重新计算每个簇的质心。\\
&5:\ until 质心不发生变化。\\
\hline
\end{aligned}</script><p>　　相似度使用欧氏距离(Euclidean Distance)度量，给定两个样本$X=(x_1,x_2,…,x_n)$与$Y=(y_1,y_2,…,y_n)$，$X$和$Y$两个向量间的欧氏距离表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned} 
dist_{ed}(X,Y)=\Vert X-Y \Vert ^2=\sqrt[2]{(x_1-y_1)^2+...+(x_n-y_n)^2}
\end{aligned}</script><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><p>　　距离计算函数<em>point_dist</em>。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">point_dist</span><span class="hljs-params">(x,c)</span></span>: <br>    <span class="hljs-keyword">return</span> np.linalg.norm(x-c)<br></code></pre></td></tr></table></figure></p>
<h4 id="iterrows-遍历方式实现"><a href="#iterrows-遍历方式实现" class="headerlink" title="iterrows 遍历方式实现"></a>iterrows 遍历方式实现</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sas">def k_means(<span class="hljs-meta">X</span>,k):<br>    centers = <span class="hljs-meta">X</span>.sample(k).values #从数据集随机选择 K 个样本作为初始化的类中心，k 行 d 列<br>    X_labels = np.zeros(l<span class="hljs-meta">en(</span><span class="hljs-meta">X</span>)) #样本的类别<br>    <span class="hljs-meta">error</span> = 10e10<br>    <span class="hljs-meta">while</span>(<span class="hljs-meta">error</span> &gt; 1e-6):<br>        for i,<span class="hljs-meta">x</span> <span class="hljs-meta">in</span> <span class="hljs-meta">X</span>.iterrows():#指派样本类标签<br>            X_labels[i] = np.ar<span class="hljs-meta">gmin(</span>[point_dist(<span class="hljs-meta">x</span>,centers[i,:]) for i <span class="hljs-meta">in</span><span class="hljs-meta"> range(</span>k)])<br>        centers_pre = centers<br>        centers = <span class="hljs-meta">X</span>.groupby(X_labels)<span class="hljs-meta">.mean(</span>).values #更新样本均值，即类中心<br>        <span class="hljs-meta">error</span> = np.linalg.norm(centers_pre - centers)#计算<span class="hljs-meta">error</span><br>    <span class="hljs-meta">return</span> X_labels, centers<br></code></pre></td></tr></table></figure>
<h4 id="apply-遍历方式实现"><a href="#apply-遍历方式实现" class="headerlink" title="apply 遍历方式实现"></a>apply 遍历方式实现</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def k_means(X,k):<br>    #初始化 K 个中心，从原始数据中选择样本<br>    centers = X.sample(k).<span class="hljs-built_in">values</span><br>    X_labels = <span class="hljs-built_in">np</span>.zeros(len(X)) #样本的类别<br>    <span class="hljs-built_in">error</span> = <span class="hljs-number">10e10</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">error</span> &gt; <span class="hljs-number">1e-6</span>):<br>        X_labels = X.<span class="hljs-built_in">apply</span>(<span class="hljs-built_in">lambda</span> r : <span class="hljs-built_in">np</span>.argmin([point_dist(r,centers[i,:]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]),axis=<span class="hljs-number">1</span>)<br>        centers_pre = centers<br>        centers = X.groupby(X_labels).<span class="hljs-built_in">mean</span>().<span class="hljs-built_in">values</span> #更新样本均值，即类中心<br>        <span class="hljs-built_in">error</span> = <span class="hljs-built_in">np</span>.linalg.norm(centers_pre - centers)#计算<span class="hljs-built_in">error</span><br>    <span class="hljs-built_in">return</span> X_labels, centers<br></code></pre></td></tr></table></figure>
<h4 id="矩阵运算方式实现"><a href="#矩阵运算方式实现" class="headerlink" title="矩阵运算方式实现"></a>矩阵运算方式实现</h4><p>　　数据集表示成 $n \times d$ 矩阵 $\mathbf{X}$，其中 $n$ 为样本数量，$d$ 为样本的维度。 $k$ 个聚类中心表示成 $k \times d$ 矩阵 $\mathbf{C}$，$\mathbf{C}$ 每一行表示一个聚类中心。样本到 $k$ 个中心的距离表示成 $n \times k$ 矩阵 $\mathbf{D}$。  </p>
<p>　　已知聚类中心，计算样本到中心距离，并将样本划分到距离最小的类的流程如下图所示。</p>
<p>　　<img src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/%E6%A0%B7%E6%9C%AC%E5%88%97%E8%A1%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="样本列表计算流程"></p>
<p>　　使用 Numpy 实现上述计算流程的代码为：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>	D[:,i] = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">np</span>.<span class="hljs-built_in">sum</span>(<span class="hljs-built_in">np</span>.square(X - C[i,:]),axis=<span class="hljs-number">1</span>))<br><span class="hljs-built_in">labels</span> = <span class="hljs-built_in">np</span>.argmin(D,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<p>　　得到样本的类标签后，聚类中心的更新流程为：1）根据类标签对样本进行分组；2）将聚类中心更新为每一组样本的均值。Python 实现的代码为：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">C = X.groupby(<span class="hljs-built_in">labels</span>).<span class="hljs-built_in">mean</span>().<span class="hljs-built_in">values</span><br></code></pre></td></tr></table></figure>
<p>　　完整实现代码：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def k_means(X,k):<br>    C = X.sample(k).<span class="hljs-built_in">values</span>  #从数据集随机选择 K 个样本作为初始化的类中心，k 行 d 列<br>    X_labels = <span class="hljs-built_in">np</span>.zeros(len(X)) #记录样本的类别<br>    <span class="hljs-built_in">error</span> = <span class="hljs-number">10e10</span> #停止迭代的阈值<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">error</span> &gt; <span class="hljs-number">1e-6</span>):<br>        D = <span class="hljs-built_in">np</span>.zeros((len(X),k)) #样本到每一个中心的距离，n 行 k 列<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            D[:,i] = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">np</span>.<span class="hljs-built_in">sum</span>(<span class="hljs-built_in">np</span>.square(X - C[i,:]),axis=<span class="hljs-number">1</span>))<br>        <span class="hljs-built_in">labels</span> = <span class="hljs-built_in">np</span>.argmin(D,axis=<span class="hljs-number">1</span>)<br>        C_pre = C<br>        <br>        temp_C = X.groupby(<span class="hljs-built_in">labels</span>).<span class="hljs-built_in">mean</span>() #更新样本均值，即类中心<br>        C = <span class="hljs-built_in">np</span>.zeros((k,X.shape[<span class="hljs-number">1</span>]))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp_C.index:<br>            C[i,:] = temp_C.loc[i,:].<span class="hljs-built_in">values</span><br>            <br>        <span class="hljs-keyword">if</span> C.shape == C_pre.shape:<br>            <span class="hljs-built_in">error</span> = <span class="hljs-built_in">np</span>.linalg.norm(C_pre - C)#计算<span class="hljs-built_in">error</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(C.shape, C_pre.shape)<br>    <span class="hljs-built_in">return</span> <span class="hljs-built_in">labels</span>, C<br></code></pre></td></tr></table></figure></p>
<h2 id="Logistic-regression"><a href="#Logistic-regression" class="headerlink" title="Logistic regression"></a>Logistic regression</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><script type="math/tex; mode=display">
\begin{aligned}
h_\theta(x)&=\theta^Tx \\
 &=\sum_{i=0}^n{\theta_i x_i} \\
 &=\theta_0 + \theta_1 x_1 + \theta_2 x_2 + ... + \theta_n x_n
\end{aligned}</script><h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><script type="math/tex; mode=display">
\begin{aligned}
g(z)=\frac{1}{1+e^{-z}}
\end{aligned}</script><h3 id="逻辑回归公式"><a href="#逻辑回归公式" class="headerlink" title="逻辑回归公式"></a>逻辑回归公式</h3><p>　　线性回归公式带入Sigmoid即得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
h_\theta(x)=\frac{1}{1+e^{-{\theta^Tx}}}
\end{aligned}</script><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>　　对数形式的似然函数如下：  </p>
<script type="math/tex; mode=display">
\begin{aligned}
logL(\theta)=\sum_{i=1}^n{log(p(x_i;\theta))} 
\end{aligned}</script><p>　　用sigmoid函数表示0-1中取1的概率，损失函数可以定义为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y&=0时，Cost(h_\theta(x),y)=-log(1-h_\theta(x)) \\
y&=1时，Cost(h_\theta(x),y)=-log(h_\theta(x)) 
\end{aligned}</script><p>　　损失函数的要求是预测结果与真实结果越相近，函数值越小，故在前面加上负号。取对数和上面提到的最大似然函数有关，不影响原函数的单调性，且会放大概率之间的差异，更好的区分各个样本的类别。<br>　　故逻辑回归的损失函数如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
J(\theta)=-\frac{1}{m}\sum_{i=1}^m{[y^{(i)}logh_\theta(x^{(i)})+(1-y^{(i)})log(1-h_\theta(x^{(i)}))]}
\end{aligned}</script><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>　　要求出最优参数$\theta$，需要最小化$J(\theta)$，更新参数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\theta_j := \theta_j-\alpha \frac{\partial J(\theta)}{\partial \theta_j}
\end{aligned}</script><p>　　sigmoid函数求导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial g(z)}{\partial z}=g(z)(1-g(z))
\end{aligned}</script><p>　　对g(\theta^Tx)求导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial g(\theta^Tx)}{\partial z}=g(\theta^Tx)(1-g(\theta^Tx))x_j^{(i)}
\end{aligned}</script><p>　　<strong>损失函数求导：</strong></p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial J(\theta)}{\partial \theta_j}&= ...\\
&=\frac{1}{m}\sum_{i}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}
\end{aligned}</script><p>　　得到逻辑回归的梯度下降更新公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\theta_j := \theta_j-\alpha  \frac{1}{m}\sum_{i}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}
\end{aligned}</script><h3 id="伪代码描述"><a href="#伪代码描述" class="headerlink" title="伪代码描述"></a>伪代码描述</h3><script type="math/tex; mode=display">
\begin{aligned} 
\hline
&1:\ 初始化回归系数。\\
&2:\ repeat \\
&3:\ \quad 计算梯度\frac{\partial J(\theta)}{\partial \theta}。\\
&4:\ \quad \theta:=\theta+\alpha * \frac{\partial J(\theta)}{\partial \theta}。\\
&5:\ until 收敛 \  or \  max\_loop。\\
&6:\ return\ \theta \\
\hline
\end{aligned}</script><h3 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LR</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, alpha=<span class="hljs-number">0</span>.<span class="hljs-number">01</span>, max_iter=<span class="hljs-number">100</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">self</span>.alpha = alpha<br>        <span class="hljs-keyword">self</span>.max_iter = max_iter<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, X, y)</span></span><span class="hljs-symbol">:</span><br>        X = np.mat(X)  <span class="hljs-comment"># (rows,cols)</span><br>        m, n = np.shape(X)<br>        y = np.mat(y).T  <span class="hljs-comment"># (rows,cols)</span><br><br>        <span class="hljs-keyword">self</span>.weight = np.ones((n, <span class="hljs-number">1</span>))<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-keyword">self</span>.max_iter)<span class="hljs-symbol">:</span><br>            h = <span class="hljs-keyword">self</span>.sigmoid(X * <span class="hljs-keyword">self</span>.weight)<br>            error = y - h<br>            <span class="hljs-keyword">self</span>.weight = <span class="hljs-keyword">self</span>.weight + <span class="hljs-keyword">self</span>.alpha * X.T * error<br><span class="hljs-string">``</span><span class="hljs-string">`r</span><br></code></pre></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/ckp5ow9ho0000islx9l7fhicr/">
                        <span class="hidden-mobile">2021招商银行FinTech精英训练营 数据赛道(Rank53)</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-code"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  










  
<script src="/js/fireworks.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>

<!-- firework -->
<script type="text/javascript" src="/js/fireworks.js"></script>